\documentclass[11pt, reqno]{amsart}
\usepackage[english]{babel}

\usepackage{layout}
\usepackage{afterpage}
\usepackage[
  asymmetric,
  textheight     = 673pt,
  marginparsep   = 7pt,
  footskip       = 27pt,
  hoffset        = 0pt,
  paperwidth     = 597pt,
  textwidth      = 452pt,
  marginparwidth = 101pt,
  voffset        = 0pt,
  paperheight    = 845pt,
]{geometry}

\newcommand{\changegeometry}{\newgeometry{includehead,headheight=89pt}%
  \afterpage{\aftergroup\restoregeometry}%
}

% Math stuff: do not mess with the ordering!
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{tikz-cd}
\usepackage{tqft}

% Font
\usepackage[no-math]{newpxtext}
\usepackage{newpxmath}
% Set arrow tip to that of newpxmath
\tikzset{>=Straight Barb, commutative diagrams/arrow style=tikz}

% Utilities
\usepackage{enumerate}
\usepackage{todonotes}
\usepackage{graphicx}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Horizontal rule
\usepackage{multirow}

% Color
\usepackage{xcolor}
\definecolor{brightmaroon}{rgb}{0.76, 0.13, 0.28}

\usepackage{pdfpages}

% References
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  allcolors  = brightmaroon,
}
\usepackage[capitalize,nameinlink]{cleveref}
\usepackage[
  backend = biber,
  style   = alphabetic,
]{biblatex}
\addbibresource{../../src/bibliography.bib}


% Table of contents: show subsections
\setcounter{tocdepth}{2}

\linespread{1.05}
\vfuzz=14pt % No more vbox errors all over the place

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** Environments **

\theoremstyle{definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{notation}[theorem]{Notation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** symbols **

\renewcommand{\qedsymbol}{\(\natural\)}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\renewcommand{\setminus}{\smallsetminus}
\renewcommand{\preceq}{\preccurlyeq}

% ':' for maps and '\colon' for relations on collections
\DeclareMathSymbol{:}{\mathpunct}{operators}{"3A}
\let\colon\relax
\DeclareMathSymbol{\colon}{\mathrel}{operators}{"3A}

% Disjoint unions over sets
\newcommand{\disj}{\amalg}     % Disjoint union
\newcommand{\bigdisj}{\coprod} % Indexed disjoint union

\DeclareMathOperator{\Log}{Log}
\newcommand{\img}{\text{i}}

% Constant map
\DeclareMathOperator{\const}{cons}

% Multiplication map
\DeclareMathOperator{\mul}{mul}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** arrows **

% Alias for Rightarrow
\newcommand{\To}{\Rightarrow}

% Monomorphism arrow
\newcommand{\mono}{\rightarrowtail}

% Epimorphism arrow
\newcommand{\epi}{\twoheadrightarrow}

% Unique morphism
\newcommand{\unique}{\to}%{\dashrightarrow}
\newcommand{\xdashrightarrow}[2][]{\ext@arrow 0359\rightarrowfill@@{#1}{#2}}

% Isomorphism symbol
\newcommand{\iso}{\simeq}

\newcommand{\arrowiso}{\iso}
% Isomorphism arrow
\newcommand{\isoto}{\xrightarrow{\raisebox{-.6ex}[0ex][0ex]{\(\arrowiso\)}}}

% How isomorphisms are depicted in diagrams: either \sim or \simeq
\newcommand{\dis}{\iso}

\newcommand{\isounique}{%
  \xdashrightarrow{\raisebox{-.6ex}[0ex][0ex]{\(\arrowiso\)}}
}%

% Natural transformation arrow
\newcommand{\nat}{\Rightarrow}

% Natural isomorphism
\newcommand{\isonat}{\xRightarrow{\raisebox{-.6ex}[0ex][0ex]{\(\arrowiso\)}}}

% Embedding arrow
\newcommand{\emb}{\hookrightarrow}

% Parallel arrows
\newcommand{\para}{\rightrightarrows}

% Adjoint arrows
\newcommand{\adj}{\rightleftarrows}

% Implication
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\impliedby}{\Leftarrow}

% Limits
\DeclareMathOperator{\Lim}{lim}     % Limit
\DeclareMathOperator{\Colim}{colim} % Colimit
\DeclareMathOperator{\Eq}{eq}       % Equalizer
\DeclareMathOperator{\Coeq}{coeq}   % Coequalizer

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** Common collections **

\newcommand{\Z}{\mathbf{Z}}
\newcommand{\N}{\mathbf{N}}
\newcommand{\Q}{\mathbf{Q}}
\newcommand{\CC}{\mathbf{C}}
\newcommand{\R}{\mathbf{R}}
\newcommand{\FF}{\mathbf{F}}

\renewcommand{\emptyset}{\varnothing}

\newcommand{\Uhs}{\mathbf{H}}  % Upper half space
\newcommand{\Proj}{\mathbf{P}} % Projective space

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** Categories **

% Font for categories
\newcommand{\cat}{\texttt}
\newcommand{\catfont}{\texttt}

% Opposite category
\newcommand{\op}{\mathrm{op}}

% Common categories
\newcommand{\Set}{{\catfont{Set}}}          % Sets
\newcommand{\FinSet}{{\catfont{FinSet}}}    % Finite sets
\newcommand{\pSet}{{\catfont{pSet}}}        % Pointed sets
\newcommand{\tOrd}{{\catfont{tOrd}}}        % Totally ordered sets

\newcommand{\Vect}{{\catfont{Vect}}}        % Vector spaces
\newcommand{\FinVect}{{\catfont{FinVect}}}  % Finite vector spaces

\newcommand{\TVect}{{\catfont{TVect}}}      % Topological vector spaces
\newcommand{\Ban}{{\catfont{Ban}}}          % Banach spaces

\newcommand{\Grp}{{\catfont{Grp}}}          % Groups
\newcommand{\Ab}{{\catfont{Ab}}}            % Abelian groups
\newcommand{\GSet}[1]{{{#1}\text{-}\Set}}   % G-sets
\newcommand{\Grpd}{{\catfont{Grpd}}}        % Groupoids

\newcommand{\Mon}{{\catfont{Mon}}}          % Monoidal category
\newcommand{\coMon}{{\catfont{coMon}}}      % coMonoidal category
\newcommand{\rActMon}{{\catfont{rActMon}}}  % right action category
\newcommand{\lActMon}{{\catfont{lActMon}}}  % left action category
\newcommand{\BrMonCat}{{\catfont{BrMonCat}}} % Cat of braided monoidal cats

\newcommand{\Graph}{{\catfont{Graph}}}      % Graphs
\newcommand{\SimpGraph}{{\catfont{sGraph}}} % Simple graphs
\newcommand{\ProfCol}{{\catfont{Prof}(\Col)}}   % C-profile category


\newcommand{\Rng}{{\catfont{Ring}}}             % Rings
\newcommand{\cRng}{{\catfont{CRing}}}           % Commutative rings
\newcommand{\rMod}[1]{{\texttt{Mod}_{#1}}}      % Right modules
\newcommand{\lMod}[1]{{{}_{#1}\catfont{Mod}}}   % Left modules
\newcommand{\Mod}[1]{{#1\text{-}\catfont{Mod}}} % Modules over comm. ring
\newcommand{\Alg}[1]{{#1\text{-}\catfont{Alg}}} % Algebras
\newcommand{\cAlg}[1]{{#1\text{-}\catfont{CAlg}}} % Commutative algebras

\newcommand{\Cat}{{\catfont{Cat}}}          % Small categories
\newcommand{\CAT}{{\catfont{CAT}}}          % Big categories
\newcommand{\UCat}{{\mathcal{U}\text{-}\catfont{Cat}}} % U-Categories

\newcommand{\Psh}[1]{{\catfont{Psh}({#1})}}   % Category of presheaves
\newcommand{\comma}{\downarrow} % Comma category separator
\DeclareMathOperator{\El}{El}              % Category of elements

\DeclareMathOperator{\Map}{Map}

% Operators
\DeclareMathOperator{\Hom}{Mor}   % Morphisms
\DeclareMathOperator{\Mono}{Mono} % Monomorphisms
\DeclareMathOperator{\Epi}{Epi}   % Epimorphisms
\DeclareMathOperator{\Fct}{Fct}   % Functors
\DeclareMathOperator{\Obj}{Obj}   % Objects
\DeclareMathOperator{\Mor}{Mor}   % Morphisms, again
\DeclareMathOperator{\End}{End}   % Endomorphisms
\DeclareMathOperator{\Aut}{Aut}   % Automorphisms
\DeclareMathOperator{\Id}{id}     % Identity
\DeclareMathOperator{\im}{im}     % Image
\DeclareMathOperator{\dom}{dom}   % Domain
\DeclareMathOperator{\codom}{cod} % Codomain
\DeclareMathOperator{\supp}{supp} % Support

% Yoneda embedding
\newcommand{\yo}{\text{\usefont{U}{min}{m}{n}\symbol{'210}}}
\DeclareFontFamily{U}{min}{}
\DeclareFontShape{U}{min}{m}{n}{<-> udmj30}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** algebra **
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\coker}{coker}
\DeclareMathOperator{\codim}{codim}
\DeclareMathOperator{\Tr}{tr}   % Trace
\DeclareMathOperator{\Sym}{Sym} % Symmetric space
\DeclareMathOperator{\Alt}{Alt} % Alternating space
\DeclareMathOperator{\Ann}{Ann} % Annihilator
\DeclareMathOperator{\Char}{char}
\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\Inn}{Inn}     % Inner automorphisms
\DeclareMathOperator{\Spec}{Spec}   % Prime spectrum
\DeclareMathOperator{\Specm}{Spec_m} % Maximal spectrum
\newcommand{\lie}[1]{\mathfrak{#1}} % Font for Lie structures
\DeclareMathOperator{\Rees}{Rees}   % Rees algebra
\DeclareMathOperator{\Frac}{Frac}   % Field of fractions

\DeclareMathOperator{\torsion}{\texttt{tor}}   % Torsion

\DeclareMathOperator{\eval}{eval}
\DeclareMathOperator{\sign}{sign}

% Matrices
\DeclareMathOperator{\Mat}{Mat}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\PSL}{PSL}
\DeclareMathOperator{\SO}{SO}
\DeclareMathOperator{\SU}{SU}
\DeclareMathOperator{\Unit}{U}
\DeclareMathOperator{\Orth}{O}

% Symbol for the group of units --- for instance, the group of units of a ring
% \(R\) will be denoted by \(R^{\unit}\).
\newcommand{\unit}{\times}

% Orbit and stabilizer
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}

% Left and right group actions
\newcommand{\laction}{\circlearrowright}
\newcommand{\raction}{\circlearrowleft}

% Ring ideals font
\newcommand{\ideal}[1]{\mathfrak{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** Topology **

\let\Top\relax
\newcommand{\Top}{{\catfont{Top}}}                       % Topological spaces

\newcommand{\wHTop}{{\catfont{wH}\text{-}\catfont{Top}}} % Weak Hausdorff
\newcommand{\kTop}{{k\text{-}\catfont{Top}}}             % k-spaces
\newcommand{\cgTop}{{\catfont{cgTop}}} % Compactly generated

\newcommand{\pTop}{{\catfont{Top}^{*}}}   % Pointed top spaces
\newcommand{\bpTop}{{\catfont{Top}^{*/}}} % Base point top spaces

\newcommand{\Ho}[1]{{\catfont{Ho}(#1)}}            % Homotopy category
\newcommand{\HoTop}{{\catfont{Ho}(\catfont{Top})}} % Classical Homotopy cat

\newcommand{\Splx}{{\mathbf{\Delta}}}           % Simplex category
\newcommand{\sSet}{{\catfont{sSet}}}            % Simplicial sets
\newcommand{\Simp}[1]{{\catfont{Simp}(#1)}}     % Simplicial category
\newcommand{\CoSimp}[1]{{\catfont{CoSimp}(#1)}} % Cosimplicial category

\newcommand{\splx}{\Delta}
\newcommand{\splxtop}{\Delta_{\text{top}}}

\DeclareMathOperator{\Sing}{Sing} % Singular complex functor
\DeclareMathOperator{\Nondeg}{nd} % Non-degenerate simplices
\newcommand{\disc}{\text{disc}}   % discrete

\DeclareMathOperator{\Sk}{sk} % Skeleton

\DeclareMathOperator{\Cof}{Cof} % Cofibrant replacement
\DeclareMathOperator{\Fib}{Fib} % Fibrant replacement
\newcommand{\operad}{\mathcal}
\newcommand{\Operad}{{\catfont{Operad}}}
\newcommand{\Tree}{{\mathbf{\Omega}}}
\DeclareMathOperator{\Input}{In}
\DeclareMathOperator{\Output}{Out}
\DeclareMathOperator{\TreeFace}{\partial}
\newcommand{\dSet}{{\catfont{dSet}}}

% attaching spaces
\newcommand{\att}{\amalg}     % Disjoint union
\newcommand{\bigatt}{\coprod} % Indexed disjoint union

% Homotopy
\newcommand{\simht}{\sim_{\text{h}}}              % Homotopy between maps
\newcommand{\simhtrel}[1]{\sim_{\text{rel }{#1}}} % Relative htpy
\newcommand{\isoht}{\iso_{\text{h}}}              % Homotopy equivalence
\newcommand{\htpy}{\Rightarrow}                   % Htpy arrow
\newcommand{\htpyrel}[1]{\Rightarrow_{\text{rel }{#1}}} % Relative htpy arrow


% Functors on topological spaces
\DeclareMathOperator{\Disc}{Disc}       % Discrete topology: Set -> Top
\DeclareMathOperator{\Cone}{Cone}       % Cone
\DeclareMathOperator{\Cyl}{Cyl}         % Cylinder
\DeclareMathOperator{\Susp}{S}          % Suspension
\DeclareMathOperator{\rSusp}{\Sigma}    % Reduced suspension
\DeclareMathOperator{\Path}{Path}       % Path object
\DeclareMathOperator{\Loop}{\Omega}       % Loop space
\DeclareMathOperator{\Eval}{eval}       % Evaluation map
\DeclareMathOperator{\curry}{curry}     % Currying a map
\DeclareMathOperator{\uncurry}{uncurry} % Currying a map
\DeclareMathOperator{\co}{co}           % Compact open co(K, U)

\newcommand{\lift}{\widehat} % Lifting of path and stuff

% Set operators
\DeclareMathOperator{\Cl}{Cl}       % Closure
\DeclareMathOperator{\Bd}{\partial} % Boundary
\DeclareMathOperator{\Int}{Int}     % Interior
\DeclareMathOperator{\Ext}{Ext}     % Exterior

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** Differentiable structures **

\newcommand{\Bun}{{\catfont{Bun}}} % Bundle category
\newcommand{\VecBun}{{\catfont{VecBun}}} % Vector Bundle category
\newcommand{\Man}{{\catfont{Man}}} % Manifolds

% Norm
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

% Differential operators
\newcommand{\diff}{\mathrm{d}}
\newcommand{\Diff}{\mathrm{D}}
\DeclareMathOperator{\grad}{grad} % Gradient
\DeclareMathOperator{\Hess}{Hess} % Hessian
\DeclareMathOperator{\Jac}{Jac}   % Jacobian
\DeclareMathOperator{\Curl}{Curl} % Curl
\DeclareMathOperator{\VecField}{\mathfrak{X}}

\DeclareMathOperator{\Grass}{Grass}    % Grassmann variety
\DeclareMathOperator{\Stie}{Stie}      % Stiefel variety

% Vector bundle
\DeclareMathOperator{\zerosec}{Zero} % Zero section

\newcommand{\trans}{\pitchfork} % Transversality

% Set operators
\DeclareMathOperator{\Vol}{vol}   % Volume
\DeclareMathOperator{\Mesh}{mesh} % Mesh

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** Graphs **

% Colouring
\newcommand{\Col}{\mathfrak{C}}
\newcommand{\prof}[1]{\underline{#1}}

\DeclareMathOperator{\Edge}{Edge}
\DeclareMathOperator{\Vertex}{Vert}
\DeclareMathOperator{\Circ}{circ}
\DeclareMathOperator{\diam}{diam}
\newcommand{\emptygraph}{\varnothing}
\DeclarePairedDelimiterX{\size}[1]{\lVert}{\rVert}{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** machine learning **

\DeclareMathOperator{\Prob}{\mathbb{P}} % Probability
\DeclareMathOperator{\Expect}{\mathbb{E}} % Expectation
\newcommand{\Mean}{\mu} % Mean
\DeclareMathOperator{\Cov}{Cov} % Covariance
\DeclareMathOperator{\Var}{Var} % Variance
\DeclareMathOperator{\Correlation}{Corr}
\DeclareMathOperator{\stdev}{\sigma} % standard deviation
\DeclareMathOperator{\ndist}{\mathcal{N}} % Normal distribution
\DeclareMathOperator{\precision}{\beta}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator{\vcdim}{VCdim}
\DeclareMathOperator{\Growth}{Growth} % Growth function
\DeclareMathOperator{\Quantile}{Quant}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ** MACROS END HERE **
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

\begin{titlepage}
 \vfill
  \begin{center}
       \textsc{\LARGE \textbf{University of São Paulo}} \\[2.0cm]

       \vskip 0.5cm
       \textsc{\large Luiz Gustavo Mugnaini Anselmo}

       {\normalsize Molecular Sciences Course \\
         Class 30, n\(^{\text{o}}\)
         USP 11809746

       E-mail: \texttt{luizmugnaini@usp.br}}\\[2.0cm]

       \HRule\\
       \vskip 0.5cm
       {\LARGE \textbf{Dendroidal Homotopy Theory \& Operads}}
       \HRule\\[1.5cm]

       \hspace{.45\textwidth}
       \begin{minipage}{.5\textwidth}
       \normalsize \textbf{Advanced Studies Report III}\\[0.5cm]

       \textsc{\large Prof.~Ivan Struchiner}\\
       University of São Paulo \\
       Institute of Mathematics and Statistics \\
       E-mail: \texttt{ivanstru@ime.usp.br}\\[1cm]

       \normalsize São Paulo, December of 2023
       \end{minipage}
  \end{center}
\end{titlepage}

% Title stuff
\title[Dendroidal Homotopy Theory \& Operads]{%
{\footnotesize\sl Advanced Studies Report III} \\ \smallskip
  Dendroidal Homotopy Theory \& Operads
}%

\author{%
  Luiz Gustavo Mugnaini Anselmo and Ivan Struchiner
}%

\address{%
  Institute of Mathematics and Statistics, University of São
  Paulo, Rua do Matão 1010, 05508--090~São Paulo, SP
}%

\email{luizmugnaini@usp.br, ivanstru@ime.usp.br}

\begin{abstract}
    This report documents the research advances of the student Luiz Gustavo Mugnaini Anselmo. During his
    third semester of the advanced cycle of the Molecular Sciences course. The main topic of research
    explored this semester was the study of model categories, operads, and dendroidal sets.
\end{abstract}
\maketitle

\section{Introduction}

In this semester we focused our research in the theory underlying operads and dendroidal sets.
Operads come as way of generalizing the idea of a category. An operad consists of a collection of
objects, while arrows are defined by their input and output---just as in a plain category. The input
of these arrows is not limited to a single object, but rather we allow for any \(n \in \N\) number
of objects as input---we however still limit the output to a single object. This extension in the
number of inputs allows us to view an operad as a multicategory. Moreover, we can visualise an arrow
in an operad as a tree, as shown in \cref{eq:operad-arrow-as-tree}. This abstraction leads to the
category \(\Operad\) which generalises our previous category of simplexes \(\Splx\). As we know from
previous studies, the category \(\Splx\) gives birth to the idea of a simplicial set and
consequently the presheaf category \(\sSet\). On the other hand, the generalisation \(\Operad\)
leads us to the presheaf category of dendroidal sets \(\dSet\) which play a crucial role in the
study of modern homotopy theory.

\section{Studies}

This section provides an overview of the subjects studied in the second
semester of 2023. The material presented is based on
\cite{Weiss07,HeuMoer22,MoerdijkWeiss07}.

\subsection{Operads}

\begin{definition}[Operad]
\label{def:operad}
A (symmetric) \emph{operad} \(\operad P\) is given by a \emph{set} of
\emph{colours} \(C\) (or objects \(\Obj(\operad P) \coloneq C\)), and for each
\(n \in \N\) and a sequence \(c_1, \dots, c_n, c \in C\) there is a set
\emph{operations} (or arrows) denoted by
\[
\operad P(c_1, \ldots, c_n; c).
\]
We think of these operations as taking \(n\) input colours \(c_1, \dots, c_n\)
and outputting a colour \(c\)---which can be visualized as a \emph{corolla}:
\begin{equation}\label{eq:operad-arrow-as-tree}
    \begin{tikzcd}
        &\ar[drr, no head, "c_1"'] 
        &\dots 
        &\ar[d, no head, "c_j"] 
        &\dots 
        &\ar[dll, no head, "c_n"]
        \\
        & & &v \ar[d, no head, "c"] & &
        \\
        & & &\phantom{v} & &
    \end{tikzcd}
\end{equation}
where \(v \in \operad P(c_1, \ldots, c_n; c)\)---which can also be denoted by
\(v: (c_1, \ldots, c_n) \to c\)---is the operation, which has \emph{arity}
\(n\).

We shall assume that if the intersection 
\[
    \operad P(c_1, \dots, c_n; c) \cap \operad P(c_1', \dots, c_m'; c')
\]
is non-empty, then \(n = m\) and for each \(1 \leq j \leq n\) we have \(c_j =
c_j'\), and \(c = c'\). Notice that since \(n \in \N\), we may have \(n = 0\)---in which case an operation \(v \in \operad P(; c)\) is depicted as
\[
    \begin{tikzcd}
        v \ar[dd, "c", no head] \\ \\
        \phantom{v}
    \end{tikzcd}
\]

The operad also implements the following structures:
\begin{enumerate}[(a)]\setlength\itemsep{0em}
    \item \emph{Identity maps}. For each colour \(c \in C\), there exists an
    identity map \(\Id_c \in \operad P(c; c)\).

    \item \emph{Composition}. For any sequence \(c_1, \dots, c_n, c \in C\) and
    any collection of sequences \(d_1^j, \dots, d_{k_j}^j, c_j\) for \(1
    \leq j \leq n\), there is a composition of operations:
    \[
    \operad P(c_1, \dots, c_n; c)
    \times \prod_{j=1}^n \operad P(d_1^j, \dots, d_{k_j}^j; c_j)
    \overset{\circ}\longrightarrow
    \operad P(d_1^1, \dots, d_{k_1}^1, d_1^2, \dots, d_{k_n}^n; c).
    \]

    Given an operation \(f \in \operad P(c_1, \dots, c_n; c)\) and operations
    \(g_j \in \operad P(d_{1}^j, \dots, d_{k_j}^j; d^j)\) for each \(1 \leq j
    \leq n\) then we denote the composition of \(f\) with the sequence \((g_1,
    \dots, g_n)\) simply as
    \[
    f (g_1, \dots, g_n).
    \]

    The composition function must be such that
    \begin{itemize}
        \item For any colour \(c, d \in C\) and operation \(f \in \operad P(d; c)\)
            one must have \(\Id_c(f) = f\).

        \item The composition is associative. Take an operation \(p \in \operad P(c_1,
            \dots, c_n; c)\), and consider the following sequence of operations:
            \[
                q_1, \dots, q_n \in \prod_{j=1}^n \operad P(d_1^j, \dots, d_{k_j}^j; c_j)
            \]
            and for each \(1 \leq j \leq n\) we take a sequence
            \[
                r_1^j, \dots, r_{k_j}^j \in 
                \prod_{i=1}^{k_j} \operad P(e_1^i, \dots, e_{t_j}^i; d_i^j)
            \]
            then the composition must be such that
            \[
                (p(q_1, \dots, q_n))(r_1^1, \dots, r_{t_1}^1, r_1^2, \dots, r_{t_n}^n)
                = p(q_1(r_1^1, \dots, r_{t_1}^1), \dots, q_n(r_1^n, \dots, r_{t_n}^n)).
            \]
    \end{itemize}


    \item \emph{Permutation action}\footnote{Non-symmetric operads, called planar
        operads, simply ignore this last condition---they are not endowed with any
    symmetric group action.}. For each permutation \(\sigma\) on \(n\) elements,
    there exists an induced map
    \[
        \operad P(c_1, \dots, c_n; c)
        \overset{\sigma^{*}}\longrightarrow
        \operad P(c_{\sigma(1)}, \dots, c_{\sigma(n)}; c).
    \]
    The symmetric group gives a right action that is compatible with the
    composition defined above, that is, \((\sigma \tau)^* = \tau^* \sigma^*\).

    For each \(0 \leq j \leq n\) consider an operation \(f_j\) with arity \(k_j\)
    such that the composition \(f_0 (f_1, \dots, f_n)\) is well defined. For each
    \(0 \leq j \leq n\) let \(\sigma_j \in \Sym(k_j)\) be a permutation on \(k_j\)
    elements. The following should hold:
    \[
        (\sigma_0 (\sigma_1, \dots, \sigma_n))^*
        \circ (f_0 \circ (f_1, \dots, f_n)
        =
        \sigma_0^*(f_0) \circ 
        (\sigma_{\sigma_0(1)}^*(f_{\sigma_0(1)}),
        \dots,
        \sigma_{\sigma_0(n)}^*(f_{\sigma_0(n)}))
    \]
\end{enumerate}
\end{definition}

\begin{example}\label{exp:composing-operations-tree}
Consider a simple example where we have an operad \(\operad P\) coloured by
\(C\), and take operations \(f \in \operad P(c_1, c_2; c)\), \(g \in \operad
P(d_1, d_2; c_1)\), and \(h \in \operad P(e_1, e_2; c_2)\) then the composition
\(f(g, h)\) is well defined and can be visualized by a planar tree as follows:
\[
    \begin{tikzcd}
         \ar[rd, no head, "d_1"'] & & \ar[dl, no head, "d_2"]
        &
        &\ar[rd, no head, "e_1"'] & & \ar[dl, no head, "e_2"]
        \\
          &g \ar[rrd, no head, "c_1"'] &
        &
        & &h \ar[lld, no head, "c_2"] &
        \\
          & &
        &f \ar[dd, "c", no head]
        & & &
        \\
          & &
        &
        &  & &
        \\
          & &
        &\phantom{f}
        & & &
    \end{tikzcd}
\]
\end{example}

Given any function of sets \(f: D \to C\) there exists an induced operad
\(f^{*} \operad P\) coloured by \(D\), explicitly given by
\[
f^{*} \operad P(d_1, \dots, d_n; d) = \operad P(f d_1, \dots, f d_n; f d).
\]

\begin{definition}[Morphism of operads]\label{def:morphism-of-operads}
Consider operads \(\operad Q\), \(\operad P\) to be coloured by \(D\) and
\(C\), respectively. We define a morphism\footnote{The notion of a morphism of
operads clearly extends that of a classical functor between two categories. For
this reason, sometimes these operad maps are called functors in the
literature.} of operads \(\phi: \operad Q \to \operad P\) to be a function of
sets \(\phi: D \to C\) for which we associate functions
\[
    \phi_{d_1, \dots, d_n; d}: \operad Q(d_1, \dots, d_n; d)
    \longrightarrow
    \operad P(\phi d_1, \dots, \phi d_n; \phi d),
\]
for all sequences \(d_1, \dots, d_n, d \in D\)---which preserves the 
composition and permutation structures. Moreover, for any sequence of operations \(f_0,
f_1, \dots, f_n\) such that \(f_0 (f_1, \dots, f_n)\) is a well defined
composition, it should be the case that
\[
    \phi(f_0(f_1, \dots, f_n)) = \phi(f_0)(\phi(f_1), \dots, \phi(f_n)),
\]
that is, the morphism distributes over composition. Also, given any colour \(d
\in D\) we impose that 
\[
    \phi \Id_d = \Id_{\phi d}.
\]
For the symmetry condition\footnote{Again, for planar non-symmetric operads,
this condition is ignored.}, we demand that if \(f\) is an \(n\)-ary operation
then for any permutation \(\sigma \in \Sym(n)\) we have
\[
    \phi(\sigma^*(f)) = \sigma^*(\phi(f)).
\]
\end{definition}

Operads, together with their morphisms, form a category which we shall denote
by \(\Operad\).

\begin{remark}
\label{rem:operad-set-to-sym-mon-cat}
The \cref{def:operad} can be further generalised by replacing \(\Set\) with any
symmetric monoidal category \(\cat E\). In such a case, we denote the category
of operads over \(\cat E\) by \(\Operad(\cat E)\).

A symmetric monoidal category \(\cat E\) has a natural structure of an operad,
whose colours are \(\Obj(\cat E)\) and for which \(\cat E(X_1, \dots, X_n; X)\)
is the collection of morphisms \(X_1 \otimes \cdots \otimes X_n \to X\) in \(\cat E\).

It should be noted, however, that we are only going to consider operads
enriched by \(\Set\).
\end{remark}

\begin{remark}[\(\Cat\) \& \(\Operad\)]
\label{rem:operad-from-a-category}
Given a small category \(\cat C\), we can define an operad \(\operad P_{\cat C}\)
whose colours are the objects of \(\cat C\), and for each sequence of colours
\(C_1, \dots, C_n, C \in \cat C\) we define the collection of operations
\[
\operad P_{\cat C}(C_1, \dots, C_n; C) \coloneq
\begin{cases}
  \Mor_{\cat C}(C_1, C), &\text{if } n = 1, \\
  \emptyset, &\text{otherwise}.
\end{cases}
\]
It is trivial to notice that this structure satisfies all conditions for an
operad. This construction naturally defines a fully faithful functor \(j_!:
\Cat \to \Operad\).

On the other hand, given an operad \(\operad P\) coloured by a set \(C\), we
define a corresponding category whose objects are the colours \(C\) and whose
morphisms are the unary operations of \(\operad P\). This allows one to
construct adjunct functors
\[
    \begin{tikzcd}
        \Cat \ar[r, shift left, "j_{!}"] &\Operad \ar[l, shift left, "j^{*}"]
    \end{tikzcd}
\]
where \(\Cat\) denotes the category composed of small categories and natural
transformations. It is to be noted that \(j_!\) is a fully faithful functor.
\end{remark}

\begin{definition}[Isomorphism inside an operad]
An operation of an operad \(\operad P\) is said to be an isomorphism if it
survives the functor \(j^*\) and is an isomorphims in the category \(j^*
\operad P\).
\end{definition}

\begin{definition}[Natural transformations in \(\Operad\)]
\label{def:nat-transf-in-operad}
For each \(1 \leq j \leq n\), consider a morphism of operads \(F_j: \operad P \to \operad Q\), and a morphism \(G: \operad P \to \operad Q\). We define a natural transformation
\[
    \alpha: (F_1, \dots, F_n) \longrightarrow G
\]
to be a collection of operations \(\{\alpha_p\}_{p \in \Obj(\operad P)}\),
where \(\alpha_p \in \operad Q(F_1 p, \dots, F_n p; G p)\)---this will be
called the component of \(\alpha\) at \(p\). We shall impose the following
condition on \(\alpha\):

Given an operation \(\psi \in \operad P(p_1, \dots, p_m; p)\), consider the
composition tree
\[
    \begin{tikzcd}
         \ar[rd, no head, "F_1 p_1"'] &\dots &\ar[dl, no head, "F_n p_1"]
        &
        &\ar[rd, no head, "F_1 p_m"'] &\dots &\ar[dl, no head, "F_n p_m"]
        \\
            &\alpha_{p_1} \ar[rrd, no head, "G p_1"'] &
        &\dots
        & &\alpha_{p_m} \ar[lld, no head, "G p_m"] &
        \\
          & &
        &G \psi \ar[dd, "G p", no head]
        & & &
        \\
          & &
        &
        &  & &
        \\
          & &
        &\phantom{f}
        & & &
    \end{tikzcd}
\]
which we shall call \(\phi_1\), and the composition tree
\[
    \begin{tikzcd}
         \ar[rd, no head, "F_1 p_1"'] &\dots &\ar[dl, no head, "F_1 p_m"]
        &
        &\ar[rd, no head, "F_n p_m"'] &\dots &\ar[dl, no head, "F_n p_m"]
        \\
            &F_1 \psi \ar[rrd, no head, "F_1 p"'] &
        &\dots
        & &F_n \psi \ar[lld, no head, "F_n p"] &
        \\
          & &
        &\alpha_p \ar[dd, "G p", no head]
        & & &
        \\
          & &
        &
        &  & &
        \\
          & &
        &\phantom{f}
        & & &
    \end{tikzcd}
\]
which we'll address as \(\phi_2\). Then if \(\sigma_{m, n}\) is the permutation
equating the input of both \(\phi_1\) and \(\phi_2\), we impose that
\[
    \sigma_{m, n}^* \phi_1 = \phi_2.
\]
The natural transformation \(\alpha\) is said to be a natural isomorphism
whenever each component \(\alpha_p\) is an isomorphism in \(\operad Q\)
\end{definition}

\begin{definition}[Equivalence of operads]
\label{def:equivalence-of-operads}
A morphism \(F: \operad P \to \operad Q\) is said to be an equivalence
of operads if there exists a contrary morphism \(G: \operad Q \to \operad
P\), and two natural isomorphisms \(\alpha: \Id_{\operad P} \to G F\) and
\(\beta: \Id_{\operad Q} \to F G\).
\end{definition}

\begin{definition}
Given a morphism of operads \(F: \operad P \to \operad Q\), we define the following:
\begin{enumerate}[(a)]\setlength\itemsep{0em}
    \item \(F\) is \emph{essentially surjective} if \(j^* F\) is an essentially
        surjective functor between categories.

    \item The morphism \(F\) is said to be \emph{full} if, given any sequence \(p_1,
        \dots, p_n, p \in \Obj(\operad P)\), the map
        \[
            F: \operad P(p_1, \dots, p_n; p) \longrightarrow
            \operad Q(F p_1, \dots, F p_n; F p)
        \]
        is surjective. On the other hand, \(F\) is said to be \emph{faithful} if the
        above map is injective. Finally, \(F\) is \emph{fully faithful} if the above
        map is a bijection.
\end{enumerate}
\end{definition}

\begin{lemma}
A morphism \(F\) of operads is an \emph{equivalence} if and only if \(F\)
is both essentially surjective and fully faithful.
\end{lemma}

\subsection{The Quillen Model Structure in The Category of Operads}

\begin{lemma}\label{lem:operad-is-complete-and-cocomplete}
The category of operads is small (co)complete. 
\end{lemma}

We now prove that the category of operads admits a Quillen model structure:

\begin{theorem}\label{thm:quillen-model-structure-operads}
The category of operads admits a Quillen model structure where we define:
\begin{enumerate}[(a)]\setlength\itemsep{0em}
    \item The weak equivalences are operadic equivalences.
    \item The cofibrations are morphisms that
        are injective on the objects.
    \item The fibrations are morphisms \(F: \operad P \to \operad Q\) such
        that: for any colour \(p \in \Obj(\operad P)\) and isomorphism \(\psi: F p
        \isoto q\) in \(\operad Q\), there exists an isomorphism \(\phi: p \isoto
        p'\) in \(\operad P\) such that \(F \phi = \psi\).
\end{enumerate}
\end{theorem}

\begin{proof}
We claim that a morphism of operads \(F: \operad P \to \operad Q\) is a trivial
fibration if and only if \(F: \Obj(\operad P) \epi \Obj(\operad Q)\) is
surjective, and \(F\) is fully faithful:
\begin{itemize}
    \item If \(F\) is a weak equivalence, by definition it is fully faithful
        and essentially surjective. Take \(q \in \Obj(\operad Q)\) and since
        \(F\) is essentially surjective, there exists \(\psi: F p \isoto q\) in
        \(\operad Q\) for some \(p \in \Obj(\operad P)\).

        Now, if \(F\) is a fibration, there exists \(\phi: p \to p'\) such that
        \(F \phi = \psi\), therefore \(F p' = q\). This proves that \(F:
        \Obj(\operad P) \to \Obj(\operad Q)\) is surjective.

    \item If \(F\) is fully faithful, for it to be a weak equivalence we just
        have to prove that \(F\) is essentially surjective. Assuming that \(F\)
        is surjective on the objects, given \(q \in \Obj(\operad Q)\) there
        exists \(p \in \Obj(\operad P)\) such that \(Fp = q\) and therefore
        \(\Id_q: Fp \isoto q\) shows that \(F\) is essentially surjective.

        We now prove that \(F\) is also a fibration. Let \(p \in \Obj(\operad
        P)\) be any colour and take an isomorphism \(\psi: Fp \isoto q\) in
        \(\operad Q\). Since \(F\) is surjective on the objects, there exists
        \(p' \in \Obj(\operad P)\) such that \(F p' = q\). Moreover, since
        \(F\) is fully faithful, then the function 
        \[
            F: \operad P(p; p') \isoto \operad Q(F p; F p') = \operad Q(F p; q) 
        \]
        is a bijection and therefore there exists a unique morphism \(\phi: p
        \to p'\) in \(\operad P\) such that \(F \phi = \psi\). Finally, since
        \(F\) preserves compositions, \(\phi\) needs to be an isomorphism. This
        proves that \(F\) is a fibration.
\end{itemize}
The proof that the special classes of morphisms are closed under retracts, and
the proof of the 2-out-of-3 property is left as a routine exercise. We now
prove the lifting property.

Let \(F: \operad P \mono \operad Q\) be a cofibration and \(G: \operad R \epi
\operad S\) be a fibration. Consider the following commutative diagram:
\[
    \begin{tikzcd}
        \operad P \ar[r, "U"] \ar[d, "F"', tail]
        &\operad R \ar[d, two heads, "G"] \\
        \operad Q \ar[r, "V"'] &\operad S
    \end{tikzcd}
\]
We need to prove that whenever \(F\) or \(G\) are weak equivalences, then there
exists a lifting \(L: \operad Q \to \operad R\) filling the commutative square.
We do this considering both cases:
\begin{itemize}
    \item Suppose that \(G\) is a trivial fibration, so that \(G: \Obj(\operad
        R) \epi \Obj(\operad S)\) is surjective and \(G\) is fully
        faithful---as we have proved above. Then one has a diagram in \(\Set\):
        \[
            \begin{tikzcd}
                \Obj(\operad P) \ar[r, "U"] \ar[d, "F"', tail]
                &\Obj(\operad R) \ar[d, two heads, "G"] \\
                \Obj(\operad Q) \ar[r, "V"'] &\Obj(\operad S)
            \end{tikzcd}
        \]
        where \(F\) is injective, and \(G\) is surjective. Therefore we are
        able to define a function of sets \(L: \Obj(\operad Q) \to \Obj(\operad
        R)\) such that \(L F = U\) and \(G L = V\). Now, in order to lift \(L\)
        to a morphism of operads we can do the following:

        Let \(\phi \in \operad Q(q_1, \dots, q_n; q)\) and
        consider its image \(V \phi \in \operad S(V q_1, \dots, V q_n; V q)\)
        under the morphism of operads \(V\). From what we discussed before,
        since \(G\) is a trivial fibration then \(G\) is a fully faithful
        morphism and therefore the function 
        \[
            G: \operad R(L q_1, \dots, L q_n; L q) \isoto \operad S(V q_1,
            \dots, V q_n; V q)
        \] 
        is a bijection. Hence one can define \(L: \operad Q \to \operad S\) as
        \(L \phi \coloneq G^{-1}(V \phi)\), which trivially satisfies \(G L =
        V\) and for any \(\psi \in \operad P(p_1, \dots, p_n; p)\) we have
        \[
            L F \psi = G^{-1}(V(F \psi)) = G^{-1} V F \psi = U \psi
        \]
        therefore \(L F = U\) as wanted.

    \item Now suppose that \(F\) is a trivial cofibration. Since \(F\) is a
        weak equivalence, there exists a morphism \(F': \operad Q \to \operad
        P\) such that \(F' F = \Id_{\operad P}\)---since \(F\) is injective on
        the objects---and a natural isomorphism \(\alpha: F F' \isoto
        \Id_{\operad Q}\), which we can define for each \(p \in \Obj(\operad
        P)\) as \(\alpha_{F p} \coloneq \Id_{F p}\).

        We'll now define the function \(L: \Obj(\operad Q) \to \Obj(\operad
        R)\). For each \(q \in \Obj(\operad Q)\) we know that
        \[
            \begin{tikzcd}
                G U F' q = V F F' q \ar[r, "\iso", "\alpha_q"'] &V q
            \end{tikzcd}
        \]
        therefore using the fact that \(G\) is a fibration we obtain another
        isomorphism 
        \[
            \beta_q: U F' q \isoto r
        \] 
        in \(\operad R\) for which
        \[
            G \beta_q = \alpha_q 
        \]
        If we now define \(L q \coloneq r\) so that
        \[
            \beta_q: UF' q \isoto L q,
        \]
        we obtain \(G L q = V q\) as wanted for one of the commuting triangles
        of the diagram. For the remaining triangle, notice that the
        commutativity of the square allows us to define \(L Fp \coloneq U p\)
        for any \(p \in \Obj(\operad P)\).

        Let \(\psi \in \operad Q(q_1, \dots, q_n; q)\) be any operation. We
        shall define the image \(L \psi\) to be given by the following
        composition tree:
        \[
            \begin{tikzcd}
                \phantom{-} \ar[d, no head, "L q_1"'] 
                &
                &\phantom{-} \ar[d, no head, "L q_n"]
                \\
                \beta^{-1}_{q_1} \ar[rd, no head, "U F' q_1"'] 
                &\dots
                &\beta^{-1}_{q_n} \ar[ld, no head, "U F' q_n"]
                \\
                &U F' \psi \ar[d, no head, "U F' q"] &
                \\
                &\beta_q \ar[d, no head, "L q"] &
                \\
                &\phantom{-} &
            \end{tikzcd}
        \]
        that is, \(L \psi \coloneq \beta_q U F' (\beta_{q_1}, \dots,
        \beta_{q_n}) \psi \in \operad R(L q_1, \dots, L q_n; L q)\).
\end{itemize}
    The above constructions show that if \(F\) or \(G\) are trivial then there
    exists \(L: \operad Q \to \operad R\) such that the following diagram
    commutes
    \[
        \begin{tikzcd}
            \operad P \ar[r, "U"] \ar[d, "F"', tail]
            &\operad R \ar[d, two heads, "G"] \\
            \operad Q \ar[r, "V"'] \ar[ru, "L" description] &\operad S
        \end{tikzcd}
    \]

    In order to close the proof we got to show that given a morphism \(F:
    \operad P \to \operad Q\) there exists factorisations of \(F\) via a
    trivial cofibration followed by a fibration, and a cofibration followed by
    a trivial fibration. We split the cases in two:
    \begin{itemize}
        \item Define an operad \(\operad P'\) to be composed of objects
            \[
                \Obj(\operad P') \coloneq
                \{
                    (p, \psi, q) \in
                    \Obj(\operad P) \times \operad Q(F p, q) \times \Obj(\operad Q)
                    \colon \psi \text{ is an isomorphism }
                \},
            \]
            and for the operations, given objects \((p_1, \psi_1, q_1), \dots,
            (p_n, \psi_n, q_n), (p, \psi, q) \in \Obj(\operad P')\) then
            \[
                \operad P'(
                    (p_1, \psi_1, q_1), \dots, (p_n, \psi_n, q_n); (p, \psi, q) 
                ) \coloneq
                \operad P(p_1, \dots, p_n; p).
            \]

            We now define a morphism \(G: \operad P \to \operad P'\) to map
            each \(p \in \Obj(\operad P)\) as \(p \mapsto (p, \Id_{F p}, F
            p)\), and operations should be mapped as \(\phi \mapsto \phi\).
            This map is clearly bijective on the objects---hence a cofibration
            and fully faithful. Furthermore, the morphism \(G\) is trivially
            essentially surjective.

            Take \(L: \operad P' \to \operad Q\) to map objects \((p, \psi, q)
            \mapsto q\) which ensures that \(F = L G\) as a function on the
            objects, and given an operation 
            \[
                \Psi \in \operad P'((p_1, \psi_1, q_1), \dots, (p_n, \psi_n,
                q_n); (p, \psi, q))
            \]
            define \(L \Psi\) to be given by the composition tree:
            \[
                \begin{tikzcd}
                    \phantom{-} \ar[d, no head, "q_1"'] 
                    &
                    &\phantom{-} \ar[d, no head, "q_n"]
                    \\
                    \psi_1^{-1} \ar[rd, no head, "F p_1"'] 
                    &\dots
                    &\psi_n^{-1} \ar[ld, no head, "F p_n"]
                    \\
                    &F \Psi \ar[d, no head, "F p"] &
                    \\
                    &\psi \ar[d, no head, "q"] &
                    \\
                    &\phantom{-} &
                \end{tikzcd}
            \]
            To see that \(L\) is a fibration, notice that given an object \((p,
            \psi, q) \in \Obj(\operad P')\) and an isomorphism \(f: L(p, \psi,
            q) \isoto q'\) in \(\operad Q\), then one has that
            \[
                f \psi: F p \isoto q = L(p, \psi, q) \isoto q'
            \]
            is an isomorphism---therefore \((p, f \psi, q') \in \Obj(\operad
            P')\). From construction, 
            \[
                \Id_p: (p, \psi, q) \isoto (p, f \psi, q')
            \]
            is an isomorphism in \(\operad P'\) and we have from the
            composition tree that 
            \[
                L \Id_p = f \psi (F \Id_p) \psi^{-1} = f \psi \Id_{F p} \psi^{-1}
                = f,
            \]
            which shows that \(L\) is a fibration.

            Moreover, given an operation \(\phi \in \operad P(p_1, \dots, p_n;
            p)\) we have 
            \[
                G \phi = \phi \in \operad P'(
                    (p_1, \Id_{F p_1}, F p_1), \dots,
                    (p_n, \Id_{F p_n}, F p_n); (p, \Id_{F p}, F p)
                )
            \]
            therefore
            \[
                L G \phi 
                = \Id_{F p} (F \phi) (\Id_{F p_1}, \dots, \Id_{F p_n})
                = F \phi.
            \]

        \item Now we show that we can decompose \(F\) as a cofibration followed
            by a trivial fibration. Define an operad \(\operad Q'\) to be given
            by objects \(\Obj(\operad Q') \coloneq \Obj(\operad P) \disj \Obj(\operad
            Q)\), and for each object \(t \in \Obj(\operad Q')\), define the notation
            \[
                \overline F t \coloneq
                \begin{cases}
                    F t, &\text{if } t \in \Obj(\operad P) \\
                    t,   &\text{if } t \in \Obj(\operad Q)
                \end{cases}
            \]
            Given any objects \(t_1, \dots, t_n, t \in \Obj(\operad Q')\) we define
            \[
                \operad Q'(t_1, \dots, t_n; t) \coloneq 
                \operad Q(\overline F t_1, \dots, \overline F t_n; \overline F t).
            \]

            Define a morphism of operads \(G: \operad P \to \operad Q'\) as
            mapping objects \(p \mapsto p\) and morphisms \(\phi \mapsto F
            \phi\). This defines a clearly injective map on the objects and
            therefore \(G\) is a cofibration.

            On the other hand, we can define \(L: \operad Q' \to \operad Q\) by
            mapping \(L t \coloneq \overline F t\) just as defined above. Given
            an operation \(\psi \in \operad Q(t_1, \dots, t_n; t)\) we make \(L
            \psi \coloneq \psi\). This definition makes \(L\) surjective on the
            objects and trivially fully faithful. It is clear that \(F = L G\)
            thus we have constructed the desired factorisation.
    \end{itemize}
\end{proof}

\subsection{The Category of Trees and Dendroidal Sets}

\begin{definition}[Tree]
\label{def:tree-operad}
A \emph{tree} \(T\) is defined to be a pair \((V, E, r)\) where \(V\) is a
finite set of \emph{vertices}, \(E\) is a non-empty finite set of \emph{edges},
and \(r \in E\) is a distinguished element called \emph{root} of \(T\). A tree
comes endowed with two functions:
\begin{enumerate}[(a)]\setlength\itemsep{0em}
\item The input function \(\Input: E \setminus r \to V\) assigns each non-root
    edge to its corresponding \emph{input vertex}.

\item The output function \(\Output: V \to E\) assigns each vertex to its
    corresponding \emph{output edge}.
\end{enumerate}
Moreover, these two functions must satisfy the following requirement: given any
non-root edge \(e \in E\), there should exist sequence of repeatedly applying
\(\Output \circ \Input\) compositions starting at \(e\) and ending at \(r\).
Graphically this process is the descent from any edge to the bottom (root) of
the tree---defining an up-down directionality to the tree.

We now define some additional terms associated to a tree:
\begin{enumerate}[(a)]\setlength\itemsep{0em}
\item The edges \(E \setminus \Output(V)\) are called \emph{leaves} of \(T\).

\item The vertices \(V \setminus \Input(E)\) are called \emph{stumps} of \(T\).

\item An \emph{outer edge} of \(T\) is an edge that is either a root or a
  leaf, that is, the edge has only one vertex. On The contrary, an \emph{inner
  edge} is one that is not outer, that is, the edge has a vertex on either
  side.

\item The valence of a vertex is defined to be the number of input edges, that
    is, the valence of \(v \in V\) is given by \(\Input^{-1}(v)\).
\end{enumerate}
We also endow the sets \(E\) and \(V\) with the following partial order: given
\(e, f \in E\) (or \(v, w \in V\)), we say that \(e < f\) if the directed path
from \(e\) to the root (or \(v\) to the root) passes through \(f\) (or \(w\)).
\end{definition}

Given a tree \(T\), one can define an operad---which we shall again refer as
\(T\)---whose colours are the set \(E(T)\), and given a planar representation
of \(T\), each vertex \(v \in V(T)\) defines an operation \(v \in
T(\Input^{-1}(v); \Output(v))\). Other operations are units \(1_e\) for each
edge \(e \in E(T)\), compositions, and permutations. This defines an operad
containing at most one operation per morphism set \(T(-; -)\).

A \emph{subtree} of \(T\) is defined to be a smaller tree contained in \(T\),
whose vertices contain all incoming and outcoming edges present in \(T\).
Therefore, an operation \(v \in T(c_1, \dots, c_n; c)\) defines a
subtree of \(T\) with \(V(v) = v\) and \(E(v) = \{c_1, \dots, c_n,
c\}\)---where \(c_1, \dots, c_n\) are leafs, and \(c\) is the root.

This allows us to define a \emph{category of trees} \(\Tree\) whose objects are
trees, and maps \(T_1 \to T_2\) are morphisms between the operads \(T_1 \to
T_2\). Notice that each object \([n] \in \Splx\) naturally defines a linear
tree whose leaf is \(0\), inner edges are \(\{1, 2, \dots, n-1\}\), and whose
root is \(n\). This shows that \(\Tree\) is but an extension of \(\Splx\), and
there exists a natural embedding
\[
    \begin{tikzcd}
        \Splx \ar[r, "i", tail] &\Tree
    \end{tikzcd}
\]

Last but not least, we can define the category of dendroidal sets:

\begin{definition}\label{def:dendroidal-sets}
A dendroidal set is a \(\Set\)-valued presheaf on the category \(\Tree\), and
the category of dendroidal sets is defined as the presheaf category
\[
    \dSet \coloneq \Psh{\Tree}.
\]
\end{definition}

Notice that each \(T \in \Tree\) gives naturally gives rise to a representable
presheaf 
\[
    \Omega[T] \coloneq \Mor_{\Tree}(-, T),
\]
which is nothing more than a dendroidal set.

\section{Faces and Horns of Trees}

Just as we did with the simplicial category \(\Splx\), and consequently to
the category of simplicial sets \(\sSet\), we'll now define the notion of a
face map for the category of trees \(\Tree\). Given a tree \(T\), we can
define the following operations 
\begin{enumerate}[(a)]\setlength\itemsep{0em}
    \item \emph{Inner face maps}. Given an inner edge \(e \in E(T)\), we can
        define a new tree \(T/e\) by contracting \(e\) and quotienting its
        corresponding vertices from each side into one. This comes with a
        canonical inclusion morphism in \(\Tree\):
        \[
            \begin{tikzcd}
                T/e \ar[r, "\TreeFace_e", tail] &T
            \end{tikzcd}
        \]
        which we shall call an inner face map of \(T\).
    \item \emph{Outer face map}. Given a vertex \(v \in V(T)\) such that
        \(\Input^{-1}(v)\) is composed of outer edges, and \(\Output(v)\) is an
        inner edge, we define the tree \(T/v\) as the removal of \(v\) together
        with the outer edges \(\Input^{-1}(v)\). This construction comes with a
        canonical inclusion morphism in \(\Tree\):
        \[
            \begin{tikzcd}
                T/v \ar[r, "\TreeFace_v", tail] &T
            \end{tikzcd}
        \]
        which we shall call an outer face map of \(T\).
\end{enumerate}
The collection of all face maps of a tree \(T\) will be denoted by
\(\TreeFace(T) \subseteq \Mor(\Tree/T)\).


\section{Next Semester}

The project ``Dendroidal Homotopy Theory \& Operads'' is now terminated and the student will move on
to study a different field---Discrete Differential Geometry and Computer Graphics.

\printbibliography

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
